#!/bin/bash
# ðŸ’« https://github.com/JaKooLit ðŸ’« #
# Main Hyprland Package#

#specific branch or release
tag="v0.53.3"
# Auto-source centralized tags if env is unset
if [ -z "${HYPRLAND_TAG:-}" ]; then
  TAGS_FILE="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)/hypr-tags.env"
  [ -f "$TAGS_FILE" ] && source "$TAGS_FILE"
fi
# Allow environment override
if [ -n "${HYPRLAND_TAG:-}" ]; then tag="$HYPRLAND_TAG"; fi

# Dry-run support
DO_INSTALL=1
if [ "$1" = "--dry-run" ] || [ "${DRY_RUN}" = "1" ] || [ "${DRY_RUN}" = "true" ]; then
    DO_INSTALL=0
    echo "${NOTE} DRY RUN: install step will be skipped."
fi

#Saving Hyprland pacakge array for future needs
hyprland=()

## WARNING: DO NOT EDIT BEYOND THIS LINE IF YOU DON'T KNOW WHAT YOU ARE DOING! ##
# Determine the directory where the script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Change the working directory to the parent directory of the script
PARENT_DIR="$SCRIPT_DIR/.."
cd "$PARENT_DIR" || exit 1

source "$(dirname "$(readlink -f "$0")")/Global_functions.sh"

# Set the name of the log file to include the current date and time
LOG="Install-Logs/install-$(date +%d-%H%M%S)_hyprland.log"
MLOG="install-$(date +%d-%H%M%S)_hyprland2.log"


printf "\n%.0s" {1..1}


printf "\n%.0s" {1..1}

# Clone, build, and install Hyprland using Cmake
printf "${NOTE} Cloning and Installing ${YELLOW}Hyprland $tag${RESET} ...\n"

# Check if Hyprland folder exists and remove it (under build/src)
SRC_DIR="$SRC_ROOT/Hyprland"
if [ -d "$SRC_DIR" ]; then
    printf "${NOTE} Removing existing Hyprland folder...\n"
    rm -rf "$SRC_DIR" 2>&1 | tee -a "$LOG"
fi

if git clone --recursive -b $tag "https://github.com/hyprwm/Hyprland" "$SRC_DIR"; then
    cd "$SRC_DIR" || exit 1
    BUILD_DIR="$BUILD_ROOT/hyprland"
    mkdir -p "$BUILD_DIR"

    # Compatibility shim for toolchains without std::vector::{insert_range,append_range}
    RANGE_HDR="$(pwd)/hypr_range_compat.hpp"
    cat >"$RANGE_HDR" <<'EOF'
#pragma once
#include <iterator>
#include <ranges>
// insert at end using a range
#define INSERT_RANGE(vec, ...) (vec).insert((vec).end(), std::ranges::begin(__VA_ARGS__), std::ranges::end(__VA_ARGS__))
// insert at explicit position using a range
#define INSERT_RANGE_AT(vec, pos, ...) (vec).insert((vec).end() == (pos) ? (vec).end() : (pos), std::ranges::begin(__VA_ARGS__), std::ranges::end(__VA_ARGS__))
// append_range compatibility for containers expecting begin/end
#define APPEND_RANGE(vec, ...) (vec).insert((vec).end(), std::begin(__VA_ARGS__), std::end(__VA_ARGS__))
EOF
    # Rewrite calls:
    #   x.insert_range(pos, rng) -> INSERT_RANGE_AT(x, pos, rng)
    #   x.insert_range(rng)      -> INSERT_RANGE(x, rng)
    #   x.append_range(rng)      -> APPEND_RANGE(x, rng)
    PATCH_FILES=$(grep -REIl --exclude-dir=.git '\.\s*(insert_range|append_range)\s*\(' . || true)
    if [ -n "$PATCH_FILES" ]; then
        # Two-arg form first (pos, rng)
        perl -0777 -pi -e 's/([A-Za-z_][[:alnum:]_:.>\-]*?)\s*\.\s*insert_range\s*\(\s*([^,]+?)\s*,\s*/INSERT_RANGE_AT($1, $2, /gs' $PATCH_FILES
        # One-arg form (rng only)
        perl -0777 -pi -e 's/([A-Za-z_][[:alnum:]_:.>\-]*?)\s*\.\s*insert_range\s*\(/INSERT_RANGE($1, /gs' $PATCH_FILES
        # append_range
        perl -0777 -pi -e 's/([A-Za-z_][[:alnum:]_:.>\-]*?)\s*\.\s*append_range\s*\(/APPEND_RANGE($1, /gs' $PATCH_FILES
    fi

    # Replace #embed with an autogenerated bytes include for toolchains lacking it
    EX_CONF="$(pwd)/example/hyprland.conf"
    EMBED_INC="$(pwd)/src/config/defaultConfig.bytes.inc"
    if [ -f "$EX_CONF" ]; then
        xxd -i -g 1 -c 16 "$EX_CONF" | sed -n '/^{/{flag=1;next} /};/{flag=0} flag p' >"$EMBED_INC" || true
        # Swap the directive in the header to include the generated bytes
        sed -ri 's|^\s*#embed\s+"\.{0,2}/\.{0,2}/example/hyprland\.conf"\s*$|#include "defaultConfig.bytes.inc"|g' src/config/defaultConfig.hpp || true
    fi

    # Compatibility: some toolchains/libstdc++ do not support std::string operator+ with std::string_view.
    # Hyprland hyprctl uses a std::string_view filename; ensure it is converted explicitly.
    HYPRCTL_MAIN="$(pwd)/hyprctl/src/main.cpp"
    if [ -f "$HYPRCTL_MAIN" ] && grep -q "std::string socketPath" "$HYPRCTL_MAIN"; then
        # Only patch if we see a "+ filename" concatenation.
        if grep -qE '\+\s*filename\s*;' "$HYPRCTL_MAIN"; then
            sed -ri 's/\+\s*filename\s*;/+ std::string(filename);/g' "$HYPRCTL_MAIN" || true
        fi
    fi

    # Apply patch only if it applies cleanly; otherwise skip
    if [ -f "$PARENT_DIR/assets/0001-fix-hyprland-compile-issue.patch" ]; then
        if patch -p1 --dry-run <"$PARENT_DIR/assets/0001-fix-hyprland-compile-issue.patch" >/dev/null 2>&1; then
            patch -p1 <"$PARENT_DIR/assets/0001-fix-hyprland-compile-issue.patch"
        else
            echo "${NOTE} Hyprland compile patch does not apply on $tag; skipping."
        fi
    fi

    # Optionally strip nixGL/Nix helper logic from start-hyprland (Debian does not need it)
    if [ -f "$PARENT_DIR/assets/0002-start-hyprland-no-nixgl.patch" ]; then
        if patch -p1 --dry-run <"$PARENT_DIR/assets/0002-start-hyprland-no-nixgl.patch" >/dev/null 2>&1; then
            patch -p1 <"$PARENT_DIR/assets/0002-start-hyprland-no-nixgl.patch"
        else
            echo "${NOTE} Hyprland start-hyprland nixGL patch does not apply on $tag; skipping."
        fi
    fi

    # Remove Nix helper sources that are no longer used (defensive)
    rm -f start/src/helpers/Nix.cpp start/src/helpers/Nix.hpp || true

    # By default, build Hyprland with bundled hyprutils/hyprlang to avoid version mismatches
    # You can force system libs by exporting USE_SYSTEM_HYPRLIBS=1 before running this script.
    USE_SYSTEM=${USE_SYSTEM_HYPRLIBS:-1}
  if [ "$USE_SYSTEM" = "1" ]; then
    export PKG_CONFIG_PATH="/usr/local/lib/pkgconfig:/usr/local/share/pkgconfig:${PKG_CONFIG_PATH:-}"
    export CMAKE_PREFIX_PATH="/usr/local:${CMAKE_PREFIX_PATH:-}"
    SYSTEM_FLAGS=(
      "-DUSE_SYSTEM_HYPRUTILS=ON"
      "-DUSE_SYSTEM_HYPRLANG=ON"
      "-DUSE_SYSTEM_HYPRWIRE=ON"
    )
    # Optional preflight: verify hyprwire is discoverable by CMake/pkg-config
    if [ ! -e "/usr/local/lib/cmake/Hyprwire/HyprwireConfig.cmake" ] && ! pkg-config --exists hyprwire 2>/dev/null; then
      echo "${NOTE} hyprwire not detected in /usr/local yet. Ensure install-scripts/hyprwire.sh ran successfully or set USE_SYSTEM_HYPRLIBS=0 to use subprojects."
    fi
  else
    # Ensure we do not accidentally pick up mismatched system headers
    unset PKG_CONFIG_PATH || true
    SYSTEM_FLAGS=(
      "-DUSE_SYSTEM_HYPRUTILS=OFF"
      "-DUSE_SYSTEM_HYPRLANG=OFF"
      "-DUSE_SYSTEM_HYPRWIRE=OFF"
      "-DBUILD_HYPRCTL=OFF"
      "-DINSTALL_HYPRCTL=OFF"
    )
  fi

    # Make sure submodules are present when building bundled deps
    git submodule update --init --recursive || true

# Preflight: ensure required build tools are present; try to install missing ones
REQUIRED_TOOLS=(clang clang++ cmake ninja pkg-config)
declare -A TOOL_PKGS=([clang]=clang [clang++]=clang [cmake]=cmake [ninja]=ninja-build [pkg-config]=pkgconf)
MISSING=()
for t in "${REQUIRED_TOOLS[@]}"; do
    if ! command -v "$t" >/dev/null 2>&1; then
        MISSING+=("$t")
    fi
done
if [ ${#MISSING[@]} -ne 0 ]; then
    echo "${NOTE} Missing build tools: ${MISSING[*]}. Attempting to install..." | tee -a "$LOG"
    for t in "${MISSING[@]}"; do
        pkg="${TOOL_PKGS[$t]}"
        if [ -n "$pkg" ]; then
            install_package "$pkg" 2>&1 | tee -a "$LOG"
        fi
    done
fi
STILL_MISSING=()
for t in "${REQUIRED_TOOLS[@]}"; do
    command -v "$t" >/dev/null 2>&1 || STILL_MISSING+=("$t")
done
if [ ${#STILL_MISSING[@]} -ne 0 ]; then
    echo -e "${ERROR} Missing required build tools after attempted installation: ${STILL_MISSING[*]}" | tee -a "$LOG"
    exit 1
fi

# Prefer clang if available; otherwise fall back to GCC
if command -v clang >/dev/null 2>&1 && command -v clang++ >/dev/null 2>&1; then
    export CC="${CC:-clang}"
    export CXX="${CXX:-clang++}"
elif command -v gcc >/dev/null 2>&1 && command -v g++ >/dev/null 2>&1; then
    export CC="${CC:-gcc}"
    export CXX="${CXX:-g++}"
else
    echo "${ERROR} No suitable C/C++ compiler found (clang/clang++ or gcc/g++)." | tee -a "$LOG"
    exit 1
fi

CONFIG_FLAGS=(
    -DCMAKE_BUILD_TYPE=Release
    -DCMAKE_C_COMPILER="${CC}"
    -DCMAKE_CXX_COMPILER="${CXX}"
    -DCMAKE_CXX_STANDARD=23
    -DCMAKE_CXX_STANDARD_REQUIRED=ON
    -DCMAKE_CXX_EXTENSIONS=ON
    -DCMAKE_CXX_FLAGS="-Wno-unknown-warning-option -include ${RANGE_HDR}"
    "${SYSTEM_FLAGS[@]}"
)
cmake -S . -B "$BUILD_DIR" "${CONFIG_FLAGS[@]}"
cmake --build "$BUILD_DIR" -j "$(nproc 2>/dev/null || getconf _NPROCESSORS_CONF)"

    if [ $DO_INSTALL -eq 1 ]; then
        if sudo cmake --install "$BUILD_DIR" 2>&1 | tee -a "$MLOG"; then
            printf "${OK} ${MAGENTA}Hyprland tag${RESET}  installed successfully.\n" 2>&1 | tee -a "$MLOG"
            
            # Update version header file for tools like fastfetch that read it at runtime
            printf "${NOTE} Updating system version header for Hyprland...\n"
            VER_OUTPUT=""
            if [ -x "$BUILD_DIR/Hyprland" ]; then
                VER_OUTPUT=$("$BUILD_DIR/Hyprland" --version)
            elif [ -x "$BUILD_DIR/hyprland" ]; then
                VER_OUTPUT=$("$BUILD_DIR/hyprland" --version)
            elif command -v Hyprland >/dev/null 2>&1; then
                VER_OUTPUT=$(Hyprland --version)
            elif command -v hyprctl >/dev/null 2>&1; then
                VER_OUTPUT=$(hyprctl version)
            fi

            if [ -n "$VER_OUTPUT" ]; then
                VERSION=$(printf '%s' "$VER_OUTPUT" | head -n1 | awk '{print $2}')
                COMMIT=$(printf '%s' "$VER_OUTPUT" | grep -oP 'commit \K[a-f0-9]+' | head -1)
                TAG=$(printf '%s' "$VER_OUTPUT" | grep -oP 'Tag: \K[^,]+' | head -1)
                COMMIT_DATE=$(printf '%s' "$VER_OUTPUT" | grep -oP '^Date:\s+\K.*' | head -1)
                COMMITS=$(printf '%s' "$VER_OUTPUT" | grep -oP 'commits:\s*\K[0-9]+' | head -1)
                DIRTY=$(printf '%s' "$VER_OUTPUT" | grep -qi 'dirty' && echo "dirty" || echo "clean")
                COMMIT_MSG=$(printf '%s' "$VER_OUTPUT" | head -n1 | sed -n 's/.*(version: \(.*\))\..*/\1/p')

                [ -z "$COMMIT" ] && COMMIT="unknown"
                [ -z "$TAG" ] && TAG="v$VERSION"
                [ -z "$COMMIT_DATE" ] && COMMIT_DATE="$(date)"
                [ -z "$COMMITS" ] && COMMITS="0"
                [ -z "$COMMIT_MSG" ] && COMMIT_MSG="version: bump"

                # Prefer versions from hyprland --version; fall back to hypr-tags.env values
                parse_ver() { printf '%s' "$VER_OUTPUT" | grep -m1 "$1:" | grep -oP '\d+\.\d+\.\d+' | head -1; }
                AQUA_VER=$(parse_ver "Aquamarine")
                HYPRLANG_VER=$(parse_ver "Hyprlang")
                HYPRUTILS_VER=$(parse_ver "Hyprutils")
                HYPRCURSOR_VER=$(parse_ver "Hyprcursor")
                HYPRGRAPHICS_VER=$(parse_ver "Hyprgraphics")

                [ -z "$AQUA_VER" ] && AQUA_VER="${AQUAMARINE_TAG#v}"
                [ -z "$HYPRLANG_VER" ] && HYPRLANG_VER="${HYPRLANG_TAG#v}"
                [ -z "$HYPRUTILS_VER" ] && HYPRUTILS_VER="${HYPRUTILS_TAG#v}"
                [ -z "$HYPRGRAPHICS_VER" ] && HYPRGRAPHICS_VER="${HYPRGRAPHICS_TAG#v}"
                [ -z "$HYPRCURSOR_VER" ] && HYPRCURSOR_VER="0.1.13"
                [ -z "$AQUA_VER" ] && AQUA_VER="0.0.0"
                [ -z "$HYPRLANG_VER" ] && HYPRLANG_VER="0.0.0"
                [ -z "$HYPRUTILS_VER" ] && HYPRUTILS_VER="0.0.0"
                [ -z "$HYPRGRAPHICS_VER" ] && HYPRGRAPHICS_VER="0.0.0"

                # AQUAMARINE_VERSION components
                AQUA_MAJOR=$(echo "$AQUA_VER" | cut -d. -f1)
                AQUA_MINOR=$(echo "$AQUA_VER" | cut -d. -f2)
                AQUA_PATCH=$(echo "$AQUA_VER" | cut -d. -f3)

                # Use printf to safely write the file
                printf '%s\n' "#pragma once" > /tmp/version_header.h.tmp
                printf '%s\n' "#define GIT_COMMIT_HASH    \"$COMMIT\"" >> /tmp/version_header.h.tmp
                printf '%s\n' "#define GIT_BRANCH         \"\"" >> /tmp/version_header.h.tmp
                printf '%s\n' "#define GIT_COMMIT_MESSAGE \"$COMMIT_MSG\"" >> /tmp/version_header.h.tmp
                printf '%s\n' "#define GIT_COMMIT_DATE    \"$COMMIT_DATE\"" >> /tmp/version_header.h.tmp
                printf '%s\n' "#define GIT_DIRTY          \"$DIRTY\"" >> /tmp/version_header.h.tmp
                printf '%s\n' "#define GIT_TAG            \"$TAG\"" >> /tmp/version_header.h.tmp
                printf '%s\n' "#define GIT_COMMITS        \"$COMMITS\"" >> /tmp/version_header.h.tmp
                printf '%s\n' "" >> /tmp/version_header.h.tmp
                printf '%s\n' "#define AQUAMARINE_VERSION \"$AQUA_VER\"" >> /tmp/version_header.h.tmp
                printf '%s\n' "// clang-format off" >> /tmp/version_header.h.tmp
                printf '%s\n' "#define AQUAMARINE_VERSION_MAJOR $AQUA_MAJOR" >> /tmp/version_header.h.tmp
                printf '%s\n' "#define AQUAMARINE_VERSION_MINOR $AQUA_MINOR" >> /tmp/version_header.h.tmp
                printf '%s\n' "#define AQUAMARINE_VERSION_PATCH $AQUA_PATCH" >> /tmp/version_header.h.tmp
                printf '%s\n' "// clang-format on" >> /tmp/version_header.h.tmp
                printf '%s\n' "#define HYPRLANG_VERSION     \"$HYPRLANG_VER\"" >> /tmp/version_header.h.tmp
                printf '%s\n' "#define HYPRUTILS_VERSION    \"$HYPRUTILS_VER\"" >> /tmp/version_header.h.tmp
                printf '%s\n' "#define HYPRCURSOR_VERSION   \"$HYPRCURSOR_VER\"" >> /tmp/version_header.h.tmp
                printf '%s\n' "#define HYPRGRAPHICS_VERSION \"$HYPRGRAPHICS_VER\"" >> /tmp/version_header.h.tmp

                TARGETS=()
                if [ -f /usr/local/include/hyprland/src/version.h ]; then
                    TARGETS+=(/usr/local/include/hyprland/src/version.h)
                fi
                if [ -f /usr/include/hyprland/src/version.h ]; then
                    # If both exist, keep /usr/include in sync to avoid fastfetch mismatch.
                    TARGETS+=(/usr/include/hyprland/src/version.h)
                fi
                if [ ${#TARGETS[@]} -eq 0 ]; then
                    # Default to /usr/local if neither header exists yet.
                    TARGETS+=(/usr/local/include/hyprland/src/version.h)
                fi

                UPDATED=0
                for tgt in "${TARGETS[@]}"; do
                    if sudo install -d "$(dirname "$tgt")" && sudo cp /tmp/version_header.h.tmp "$tgt" 2>&1 | tee -a "$MLOG"; then
                        UPDATED=1
                    fi
                done

                if [ $UPDATED -eq 1 ]; then
                    printf "${OK} System version header updated to $VERSION\n" 2>&1 | tee -a "$MLOG"
                else
                    printf "${NOTE} Could not update system version header (non-critical)\n" 2>&1 | tee -a "$MLOG"
                fi
                rm -f /tmp/version_header.h.tmp
            else
                printf "${NOTE} Could not determine Hyprland version output for header update (non-critical)\n" 2>&1 | tee -a "$MLOG"
            fi
        else
            echo -e "${ERROR} Installation failed for ${YELLOW}Hyprland $tag${RESET}" 2>&1 | tee -a "$MLOG"
        fi
    else
        echo "${NOTE} DRY RUN: Skipping installation of Hyprland $tag."
    fi
    [ -f "$MLOG" ] && mv "$MLOG" "$PARENT_DIR/Install-Logs/"
    cd ..
else
    echo -e "${ERROR} Download failed for ${YELLOW}Hyprland $tag${RESET}" 2>&1 | tee -a "$LOG"
fi

printf "\n%.0s" {1..2}
